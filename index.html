<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>

  <script  src="createList.js" type="text/javascript"></script>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=DM+Sans:ital,opsz,wght@0,9..40,100..1000;1,9..40,100..1000&display=swap" rel="stylesheet">

  <link rel="stylesheet" href="./styles/global.css">
  <link rel="stylesheet" href="./styles/category-page.css">

  <style>


    ul {
      padding: 0;
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      grid-template-rows: auto;
      gap: 1rem;
      flex-wrap: wrap;
      max-width: 1140px;
      margin: 0 auto;

      list-style-type: none;

      li.lista-produto {
        border-radius: 16px;

        overflow: hidden;
        box-shadow: 0px 0px 8px #371f3e17;

        img {
          max-width: 100%;
          height: auto;
          aspect-ratio: 4 / 5;
          object-fit: cover;
        }

        a {
          display: inline-block;
          padding: 20px;
          background-color: #371f3e;
          color: white;
        }

      }
    }
  </style>
</head>
<body>

  <a href="./categorias/category-page.html">Página de categoria</a>
  <ul class="list-products">
  </ul>


<script>
  let productsClean = [];
  // let colorsGlobalName = [];
  let listIteration = [];

  async function fetchProducts (page = 1 , dataProducts = []) {
    const apiEndpoint = `https://lissfitness.com.br/wp-json/wc/v3/products?page=${page}&per_page=100&orderby=title&order=asc&stock_status=instock&consumer_key=ck_148198b90ab9d891ca88eb7368afec072dbe43d0&consumer_secret=cs_6be934eea1423037e5ff3e18ba247bd65a3eb856`;

    console.log(`Fetching page: ${page}`)
    const responseProducts = await fetch(apiEndpoint).then( x => x.json()).catch((e) => {
      console.error(e) // error handling
      return [] //returns no-results
    })
    console.log(`Fetched ${responseProducts.length} ${responseProducts.length !== 1 ? 'items' : "item"} on page ${page}`)

    responseProducts.forEach(product => {
      dataProducts.push(product);
    });

    page++

    if(responseProducts.length >= 100) return fetchProducts(page,dataProducts)
    else return dataProducts
  }

  // Executa a função de recuperar os itens da API e gera uma lista tratada a partir das informações obtidas
  fetchProducts().then(products => {
    // Para cada produto no array 'products' irá,
    // -> extrair a informação de cor do nome do produto,
    // -> associar a cor a uma key no objeto do produto,
    // -> extrair a informação de nome do produto até o nome do tecido,
    // -> criar um novo array com o objeto do produto e todas as suas informações de base,
    // -> associar todas as cores extraídas ao seu devido produto,
    // -> associar todas as imagens das cores às suas variações específicas

    // Lista que irá guardar todos os nomes (sem a cor) de produtos já processados
    let listIterationLocal = [];

    products.forEach(product => {

      // -> extrair a informação de cor do nome do produto,
      // -> associar a cor a uma key no objeto do produto,
      product.color_variations = product.name.split(/\b(Compressão |Suplex Poliamida |Dryfit |Tule | Trilobal |Jacquard Ondinha |Jacquard Zig |Jacquard Zebra |Jacquard Boreal |Jacquard Spot |Jacquard Chevry )\b/gm).pop();
      // -> extrair a informação de nome do produto até o nome do tecido, e gravar na variavel "name"
      let name = product.name.split(" " + product.color_variations).shift()

      // Caso o nome não exista na lista de iteração, fazer algumas coisas
      if (listIterationLocal.indexOf(name) === -1) {

        // Registrar nome na lista de iteração para as próximas conferências em 'products'
        listIterationLocal.push(name = name);

        let productNew = {
          id: product.id,
          name: product.name,
          slug: product.slug,
          permalink: product.permalink ,
          status: product.status ,
          date_created: product.date_created ,
          catalog_visibility: product.catalog_visibility ,
          sku: product.sku ,
          price: product.price ,
          price_sale: product.price_sale ,
          price_interest: product.price_interest ,
          price_interest_sale: product.price_interest_sale ,
          on_sale: product.on_sale ,
          stock_status: product.stock_status ,
          price_sale_interest: product.price_sale_interest ,
          categories: product.categories ,
          images: product.images ,
          attributes: product.attributes
        }

        productsClean.push(productNew);

      }


      // Criar um objeto novo a partir das informações processadas. Se um objeto de mesmo name já foi processado, apenas adicionar os objetos pertinentes ao objeto já existente.
      listIteration = listIterationLocal;
    });

    // -> Salvar o array novo em uma variável global,

    console.log(listIteration);
  });

  // fetchProducts().then( products => {
  //   listProductsRaw = products
  //   let listNameIteration = [];
  //   listProductsRaw.forEach(product => {
  //     // Para cada Produto guardado no array, guarda o último trecho escrito (a cor) em uma nova key (color_variations) do objeto Produto
  //     if (product.type == "simple")
  //     product.color_variations = product.name.split(/\b(Compressão |Suplex Poliamida |Dryfit |Tule | Trilobal |Jacquard Ondinha |Jacquard Zig |Jacquard Zebra |Jacquard Boreal |Jacquard Spot |Jacquard Chevry )\b/gm).pop();

  //     // Descarta a cor e o espaço anterior a ela, deixando apeans o nome do produto + tecido na string
  //     let name = product.name.split(" " + product.color_variations).shift()

  //     // Adiciona objetos dos produtos a uma matriz caso eles já não existam nela
  //     if (listNameIteration.indexOf(name) === -1) {
  //       console.log(name);

  //       listNameIteration.push(name);
  //       listProductsClean.push(
  //         {
  //           id: product.id,
  //           name: name,
  //           variations_color: {
  //             color: product.color_variations,
  //             images: product.images
  //           }
  //         }
  //       )
  //       // Repete o nome da cor abaixo do objeto, >só para saber se a iteração está funcionando<
  //       listProductsClean.push(product.color_variations)

  //       // Caso os nomes existam na matriz, adiciona os nomes das cores abaixo do objeto, >só para saber se a iteração está funcionando<
  //     } else {
  //       listProductsClean.push(product.color_variations)
  //     }

  //     // Guarda a cor em um array desde que ela já não exista
  //     if (colorsGlobalName.indexOf(product.color_variations) === -1) {
  //       colorsGlobalName.push(product.color_variations);
  //     }


  //     // Ordena o array global de cores alfabeticamente
  //     colorsGlobalName.sort();
  //   });
  // });

</script>


</body>
</html>